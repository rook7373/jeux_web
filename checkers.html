<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
<title>Dames - Arena Final</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
    body { background: radial-gradient(circle at center, #0a2f1a 0%, #000000 100%); color: white; min-height: 100vh; overflow-x: hidden; font-family: 'Inter', sans-serif; }
    #board { display: grid; grid-template-columns: repeat(10, 1fr); grid-template-rows: repeat(10, 1fr); width: 100%; max-width: 600px; aspect-ratio: 1/1; box-shadow: 0 25px 50px rgba(0,0,0,0.8); border-radius: 1.5rem; overflow: hidden; border: 4px solid rgba(255,255,255,0.05);}
    .square { width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:2.5rem;cursor:pointer;position:relative;transition: background-color 0.2s;}
    
    /* Couleurs du damier */
    .light-square { background-color: rgba(255, 255, 255, 0.15); }
    .dark-square { background-color: rgba(0, 50, 25, 0.8); }
    
    .piece { user-select:none;width:100%;height:100%;display:flex;align-items:center;justify-content:center;z-index: 10; }
    
    /* SÃ©lection et Mouvements */
    .selected { background-color: rgba(29, 255, 175, 0.5) !important; }
    
    /* Indicateur de mouvement (Rond violet pour bien voir) */
    .highlight-move::after { 
        content:''; position:absolute; width:25%; height:25%; 
        background-color: #d946ef; border-radius:50%; 
        box-shadow: 0 0 10px #d946ef; animation: pulse 1.5s infinite;
    }
    
    /* Indicateur de capture (Fond rouge/orange) */
    .highlight-capture { background-color: rgba(255, 100, 29, 0.6) !important; box-shadow: inset 0 0 15px rgba(255, 100, 29, 0.9); }
    
    @keyframes pulse { 0% {transform:scale(1);} 50% {transform:scale(1.3);} 100% {transform:scale(1);} }

    .color-dot { width:45px;height:45px;border-radius:50%;cursor:pointer;border:4px solid transparent;transition:0.3s; }
    .color-dot.active { border-color:#fff; transform:scale(1.2); box-shadow:0 0 15px rgba(255,255,255,0.5);}
    input::placeholder { color: #9ca3af; }
</style>
</head>
<body class="p-4 flex items-center justify-center font-sans uppercase font-black">

<div id="setup" class="max-w-md w-full bg-white p-8 md:p-12 rounded-[3.5rem] shadow-2xl text-slate-900 z-50">
    <h2 id="setup-title" class="text-4xl font-black mb-8 text-green-900 text-center italic tracking-tighter uppercase">DAMES ARENA</h2>

    <div id="mode-selector" class="grid grid-cols-2 gap-4 mb-8">
        <button type="button" onclick="setMode('local')" id="m-local" class="bg-green-600 text-white py-4 rounded-2xl shadow-lg font-black">LOCAL</button>
        <button type="button" onclick="setMode('remote')" id="m-remote" class="bg-slate-200 text-slate-500 py-4 rounded-2xl font-black">EN LIGNE</button>
    </div>

    <div id="local-options" class="space-y-4 mb-8">
        <p class="text-center text-[10px] font-black text-slate-400">CHOIX DE L'ADVERSAIRE :</p>
        <div class="grid grid-cols-2 gap-3">
            <button type="button" onclick="setOpponent('ai')" id="opp-ai" class="bg-green-600 text-white py-4 rounded-2xl text-xs font-black shadow-md">ðŸ¤– IA</button>
            <button type="button" onclick="setOpponent('human')" id="opp-human" class="bg-slate-200 text-slate-500 py-4 rounded-2xl text-xs font-black">ðŸ‘¤ HUMAIN</button>
        </div>
    </div>

    <div class="space-y-6">
        <div class="text-center">
            <p class="text-[10px] text-slate-400 mb-4 tracking-widest uppercase">TA COULEUR</p>
            <div class="flex justify-center gap-4 flex-wrap">
                <div onclick="setColor('red')" id="c-red" class="color-dot active" style="background-color:#f87171;"></div>
                <div onclick="setColor('black')" id="c-black" class="color-dot" style="background-color:#60a5fa;"></div>
            </div>
        </div>

        <input type="text" id="my-name-in" onkeydown="if(event.key==='Enter') startAction()" placeholder="TON PSEUDO..." class="w-full bg-slate-100 p-5 rounded-3xl outline-none text-xl text-center font-black uppercase shadow-inner">

        <button onclick="startAction()" class="w-full bg-black text-white py-7 rounded-3xl text-2xl shadow-xl active:scale-95 transition-all font-black">DÃ‰MARRER</button>
        <a href="index.html" class="block w-full text-center text-slate-400 text-[10px] tracking-widest uppercase font-black py-2">RETOUR HUB</a>
    </div>
</div>

<div id="game" class="hidden relative max-w-4xl w-full bg-black/40 backdrop-blur-xl p-6 md:p-8 rounded-[3.5rem] border-4 border-white/5">
    <div class="flex justify-between items-center mb-8">
        <a href="index.html" class="text-[10px] bg-white/10 px-6 py-3 rounded-full hover:bg-white/20 transition font-black">QUITTER</a>
        <div id="players-display" class="flex gap-4 md:gap-8 text-sm md:text-base tracking-widest items-center font-black"></div>
        <button onclick="copyLink()" id="btn-copy" class="hidden bg-green-600 text-white text-[10px] px-4 py-2 rounded-full tracking-widest shadow-lg active:scale-90 transition-all font-black uppercase">LIEN</button>
    </div>
    
    <div class="flex justify-center mb-6 relative">
        <div id="board"></div>
    </div>
    
    <div id="win-overlay" class="hidden text-center backdrop-blur-md bg-black/80 absolute inset-0 m-4 md:m-8 rounded-[3rem] flex flex-col items-center justify-center z-50">
        <p id="win-text" class="text-5xl text-yellow-400 mb-8 italic tracking-tighter"></p>
        <div class="flex gap-4">
            <button onclick="location.reload()" class="bg-white/20 text-white px-10 py-4 rounded-full text-sm font-black shadow-xl hover:bg-white/30 transition uppercase">Rejouer</button>
        </div>
    </div>
</div>

<script>
const API='api_checkers.php';
const ROWS=10,COLS=10;
let roomId=new URLSearchParams(window.location.search).get('room');
let myName='',myColor='red',gameMode=roomId?'remote':'local',localOpponent='ai';
let gameState={players:[],board:[],currentPlayer:'',lastMove:null,gameOver:false,winner:'',selectedPiece:null,possibleMoves:[]};

// rp = pion rouge, bp = pion noir (bleu)
const initialBoard=[
    ['','bp','','bp','','bp','','bp','','bp'],
    ['bp','','bp','','bp','','bp','','bp',''],
    ['','bp','','bp','','bp','','bp','','bp'],
    ['bp','','bp','','bp','','bp','','bp',''],
    ['','','','','','','','','',''],
    ['','','','','','','','','',''],
    ['rp','','rp','','rp','','rp','','rp',''],
    ['','rp','','rp','','rp','','rp','','rp'],
    ['rp','','rp','','rp','','rp','','rp',''],
    ['','rp','','rp','','rp','','rp','','rp']
];

window.onload=()=>{
    if(roomId){
        document.getElementById('mode-selector').classList.add('hidden');
        document.getElementById('local-options').classList.add('hidden');
        document.getElementById('setup-title').innerHTML="REJOINDRE <span class='text-slate-200'>ARENA</span>";
        gameMode='remote';
    } else {
        setMode('local');
        setOpponent('ai');
    }
}

function setMode(m){ gameMode=m; updateUI(); }
function setOpponent(opp){ localOpponent=opp; updateUI(); }
function updateUI(){
    document.getElementById('m-local').className=(gameMode==='local'?"bg-green-600 text-white py-4 rounded-2xl shadow-lg font-black":"bg-slate-200 text-slate-500 py-4 rounded-2xl font-black"); 
    document.getElementById('m-remote').className=(gameMode==='remote'?"bg-green-600 text-white py-4 rounded-2xl shadow-lg font-black":"bg-slate-200 text-slate-500 py-4 rounded-2xl font-black"); 
    document.getElementById('local-options').classList.toggle('hidden', gameMode!=='local');
    document.getElementById('opp-ai').className=(localOpponent==='ai'?"bg-green-600 text-white py-4 rounded-2xl text-xs font-black shadow-md":"bg-slate-200 text-slate-500 py-4 rounded-2xl text-xs font-black"); 
    document.getElementById('opp-human').className=(localOpponent==='human'?"bg-green-600 text-white py-4 rounded-2xl text-xs font-black shadow-md":"bg-slate-200 text-slate-500 py-4 rounded-2xl text-xs font-black");
}
function setColor(c){ myColor=c; document.querySelectorAll('.color-dot').forEach(d=>d.classList.remove('active')); document.getElementById('c-'+c).classList.add('active'); }

async function startAction(){
    const name=document.getElementById('my-name-in').value.trim(); 
    if(!name) return alert("Choisis un pseudo !"); 
    myName=name.toUpperCase();
    
    gameState.board=JSON.parse(JSON.stringify(initialBoard));
    
    if(gameMode==='remote'){
        if(!roomId) roomId=Math.random().toString(36).substring(2,8); 
        window.history.pushState({},'',`?room=${roomId}`);
        await syncPull();
        if(!gameState.players.find(p=>p.name===myName)){
            if(gameState.players.length<2){ 
                gameState.players.push({name:myName,color:myColor}); 
                if(gameState.players.length===1) gameState.currentPlayer='red'; 
            } else return alert("La salle est pleine !");
        } 
        setInterval(syncPull,2000);
    } else {
        gameState.players=[
            {name:myName, color:myColor},
            {name:localOpponent==='ai'?'IA':'JOUEUR 2', color:(myColor==='red'?'black':'red')}
        ];
        gameState.currentPlayer='red'; // Les rouges commencent toujours
    }

    document.getElementById('setup').classList.add('hidden'); 
    document.getElementById('game').classList.remove('hidden'); 
    if(gameMode==='remote') { document.getElementById('btn-copy').classList.remove('hidden'); await syncPush(); }
    
    render();

    // Si je joue Noir et que c'est le tour des Rouges (IA), lancer l'IA
    if(gameMode === 'local' && localOpponent === 'ai' && gameState.currentPlayer !== myColor){
        setTimeout(aiMove, 1000);
    }
}

// SYNC
async function syncPush(){ if(roomId) await fetch(`${API}?action=sync&roomId=${roomId}`,{method:'POST',body:JSON.stringify(gameState)}); }
async function syncPull(){ 
    if(!roomId) return; 
    try{ 
        const r=await fetch(`${API}?action=sync&roomId=${roomId}&t=${Date.now()}`); 
        const data=await r.json(); 
        if(data){ 
            const wasOver=gameState.gameOver; 
            gameState=data; 
            if(wasOver!==gameState.gameOver) document.getElementById('win-overlay').classList.toggle('hidden',!gameState.gameOver); 
            render(); 
        } 
    } catch(e){ console.error(e);} 
}

const isOnBoard=(r,c)=>r>=0&&r<ROWS&&c>=0&&c<COLS;

function getCheckersPieceChar(piece){
    const color=piece.charAt(0);
    const isKing=piece.charAt(1)==='k';
    const pieceColor=color==='r'?'#f87171':'#60a5fa';
    const crown=isKing?'<span style="color:#facc15;font-size:1.5rem;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);text-shadow:0 0 5px black;">ðŸ‘‘</span>':'';
    return `<div class="piece" style="width:80%;height:80%;background-color:${pieceColor};border-radius:50%;position:relative;box-shadow:inset 0 -4px 8px rgba(0,0,0,0.4),0 4px 8px rgba(0,0,0,0.3);border:2px solid rgba(255,255,255,0.1);">${crown}</div>`;
}

// VÃ©rifie si un joueur DOIT manger
function hasAnyCapturesForPlayer(color){
    for(let r=0;r<ROWS;r++){ 
        for(let c=0;c<COLS;c++){ 
            const piece=gameState.board[r][c]; 
            if(piece && piece.startsWith(color)){ 
                const moves=getPossibleMovesForPiece(r,c,true); // Check seulement les captures
                if(moves.some(m=>m.isCapture)) return true; 
            } 
        } 
    } 
    return false;
}

function getPossibleMoves(row,col){ 
    const mustCapture=hasAnyCapturesForPlayer(gameState.currentPlayer); 
    const moves = getPossibleMovesForPiece(row,col,mustCapture);
    
    // Si capture obligatoire, on ne garde que les captures
    if(mustCapture) return moves.filter(m=>m.isCapture);
    return moves;
}

function getPossibleMovesForPiece(row,col,mustCapture){
    const piece=gameState.board[row][col]; if(!piece) return [];
    const color=piece.charAt(0); // 'r' ou 'b'
    const opponent=color==='r'?'b':'r';
    const isKing=piece.charAt(1)==='k';
    
    // 4 diagonales
    const directions=[{dr:-1,dc:-1},{dr:-1,dc:1},{dr:1,dc:-1},{dr:1,dc:1}]; 
    const moves=[]; 
    
    for(const dir of directions){
        // DIRECTION AUTORISÃ‰E POUR LE PION ?
        // Rouge ('r') va vers le haut (-1), Noir ('b') va vers le bas (+1)
        const isForward = (color === 'r' && dir.dr === -1) || (color === 'b' && dir.dr === 1);
        
        let r=row+dir.dr,c=col+dir.dc; 
        
        // Boucle pour vÃ©rifier la ligne (utile pour les Dames qui volent)
        // Pour un pion normal, la boucle s'arrÃªtera aprÃ¨s 1 itÃ©ration grÃ¢ce au 'break'
        while(isOnBoard(r,c)){
            
            if(!gameState.board[r][c]){
                // --- CASE VIDE ---
                // On peut y aller si:
                // 1. On n'est pas obligÃ© de manger ailleurs (!mustCapture)
                // 2. ET (C'est une dame OU C'est vers l'avant)
                if(!mustCapture && (isKing || isForward)){
                    moves.push({row:r,col:c,isCapture:false});
                }
                
                // Si c'est un pion simple, on s'arrÃªte aprÃ¨s une case vide
                if(!isKing) break; 
                
            } else if(gameState.board[r][c].startsWith(opponent)){
                // --- PIÃˆCE ADVERSE (Tentative de capture) ---
                let jumpR=r+dir.dr, jumpC=c+dir.dc; 
                
                // VÃ©rifier si la case DERRIÃˆRE l'adversaire est libre
                let capturedPositions=[{row:r,col:c}];
                
                // Tant qu'on atterrit sur du vide (pour les dames qui glissent aprÃ¨s manger)
                while(isOnBoard(jumpR,jumpC) && !gameState.board[jumpR][jumpC]){
                    moves.push({row:jumpR,col:jumpC,isCapture:true,captured:[...capturedPositions]});
                    if(!isKing) break; // Le pion s'arrÃªte juste derriÃ¨re
                    jumpR+=dir.dr; jumpC+=dir.dc;
                }
                break; // On ne peut pas sauter deux piÃ¨ces collÃ©es
            } else {
                break; // BloquÃ© par une piÃ¨ce amie
            }
            
            r+=dir.dr; c+=dir.dc;
        }
    }
    return moves;
}

let mustContinueJump=false,jumpingPiece=null;

function makeMove(from,to){
    const piece=gameState.board[from.row][from.col];
    gameState.board[to.row][to.col]=piece; 
    gameState.board[from.row][from.col]='';
    
    if(to.isCapture) {
        to.captured.forEach(p=>gameState.board[p.row][p.col]='');
    }
    
    // Promotion en Dame
    let promoted = false;
    if(piece==='rp' && to.row===0) { gameState.board[to.row][to.col]='rk'; promoted=true; }
    else if(piece==='bp' && to.row===ROWS-1) { gameState.board[to.row][to.col]='bk'; promoted=true; }

    // EnchaÃ®ner les sauts (Rafle)
    if(to.isCapture && !promoted){
        // Regarder si on peut ENCORE manger depuis la nouvelle position
        const subsequentJumps=getPossibleMovesForPiece(to.row,to.col,true).filter(m=>m.isCapture);
        if(subsequentJumps.length>0){ 
            mustContinueJump=true; 
            jumpingPiece={row:to.row,col:to.col}; 
            gameState.possibleMoves=subsequentJumps; 
            gameState.selectedPiece={row:to.row,col:to.col}; 
            render();
            return; // On ne change pas de tour
        }
    }

    mustContinueJump=false; 
    jumpingPiece=null; 
    gameState.lastMove={from,to};
    
    // Changement de tour
    gameState.currentPlayer=(gameState.currentPlayer==='red'?'black':'red');
    gameState.selectedPiece=null;
    gameState.possibleMoves=[];
    
    checkGameEnd();
    
    if(gameMode==='remote') syncPush();
    
    // Trigger AI
    if(!gameState.gameOver && gameMode==='local' && localOpponent==='ai' && gameState.currentPlayer !== myColor){
        setTimeout(aiMove, 700);
    }
}

function handleSquareClick(row,col){
    if(gameState.gameOver) return;

    // VÃ©rifier si c'est mon tour
    let canClick = false;
    if(gameMode === 'local'){
        if(localOpponent === 'ai'){
            // En local vs AI, je ne peux jouer que ma couleur
            if(gameState.currentPlayer === myColor) canClick = true;
        } else {
            // Humain vs Humain : tout le monde clique
            canClick = true;
        }
    } else {
        // En ligne
        if(gameState.currentPlayer === myColor) canClick = true;
    }

    if(!canClick) return; 

    const piece=gameState.board[row][col];
    const isCurrentPlayerPiece = piece && piece.startsWith(gameState.currentPlayer);

    // Cas Rafle obligatoire
    if(mustContinueJump){
        if(row!==jumpingPiece.row || col!==jumpingPiece.col){
            const move = gameState.possibleMoves.find(m=>m.row===row && m.col===col);
            if(move) makeMove(jumpingPiece, move);
        }
        render();
        return;
    }

    // Cas Normal
    if(gameState.selectedPiece){
        // Si on clique sur une case verte/rouge (un mouvement valide)
        const move = gameState.possibleMoves.find(m=>m.row===row && m.col===col);
        if(move){
            makeMove(gameState.selectedPiece,move);
        } else if(isCurrentPlayerPiece){
            // Changer de piÃ¨ce
            gameState.selectedPiece={row,col};
            gameState.possibleMoves=getPossibleMoves(row,col);
        } else {
            // Annuler
            gameState.selectedPiece=null;
            gameState.possibleMoves=[];
        }
    } else if(isCurrentPlayerPiece){
        // SÃ©lectionner
        gameState.selectedPiece={row,col};
        gameState.possibleMoves=getPossibleMoves(row,col);
    }
    render();
}

function render(){
    const boardEl=document.getElementById('board'); 
    boardEl.innerHTML='';
    for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
            const sq=document.createElement('div'); 
            sq.className='square '+((r+c)%2===0?'light-square':'dark-square');
            sq.onclick=()=>handleSquareClick(r,c);
            
            const piece=gameState.board[r][c]; 
            if(piece) sq.innerHTML=getCheckersPieceChar(piece);
            
            // SÃ©lection
            if(gameState.selectedPiece && gameState.selectedPiece.row===r && gameState.selectedPiece.col===c) 
                sq.classList.add('selected');
            
            // Mouvements possibles
            const move = gameState.possibleMoves.find(m=>m.row===r && m.col===c);
            if(move) sq.classList.add(move.isCapture?'highlight-capture':'highlight-move');
            
            boardEl.appendChild(sq);
        }
    }
    
    // Info
    const curP = gameState.currentPlayer==='red'?"ROUGES":"BLEUS";
    const infoDiv = document.getElementById('players-display');
    infoDiv.innerText = `TOUR : ${curP}`;
    infoDiv.style.color = gameState.currentPlayer==='red'?"#f87171":"#60a5fa";
}

function checkGameEnd(){
    const reds=gameState.board.flat().filter(p=>p && p.startsWith('r')).length;
    const blacks=gameState.board.flat().filter(p=>p && p.startsWith('b')).length;
    
    if(reds===0) endGame('black');
    else if(blacks===0) endGame('red');
}

function endGame(winnerColor){
    gameState.gameOver=true;
    gameState.winner=winnerColor;
    const txt = document.getElementById('win-text');
    txt.innerText=`${winnerColor==='red'?'ROUGES':'BLEUS'} GAGNENT !`;
    txt.className = "text-5xl mb-8 italic tracking-tighter " + (winnerColor==='red'?"text-red-400":"text-blue-400");
    document.getElementById('win-overlay').classList.remove('hidden');
}

function aiMove(){
    if(gameState.gameOver) return;
    
    const aiColor = (myColor === 'red') ? 'b' : 'r'; 
    if(!gameState.currentPlayer.startsWith(aiColor === 'r' ? 'red' : 'black')) return;

    let possiblePlays = [];

    // Rafle IA
    if(mustContinueJump){
         const moves = getPossibleMovesForPiece(jumpingPiece.row, jumpingPiece.col, true);
         if(moves.length > 0){
             const randomMove = moves[Math.floor(Math.random()*moves.length)];
             makeMove(jumpingPiece, randomMove);
             render();
             return; 
         }
    }

    // Scan complet
    for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
            if(gameState.board[r][c] && gameState.board[r][c].startsWith(aiColor)){
                const moves=getPossibleMoves(r,c);
                if(moves.length > 0){
                    possiblePlays.push({r,c,moves});
                }
            }
        }
    }

    if(possiblePlays.length===0){ endGame(myColor); return; }

    const captures = possiblePlays.filter(p => p.moves.some(m => m.isCapture));
    const selectionPool = captures.length > 0 ? captures : possiblePlays;
    const choice = selectionPool[Math.floor(Math.random()*selectionPool.length)];
    const validMoves = captures.length > 0 ? choice.moves.filter(m=>m.isCapture) : choice.moves;
    const move = validMoves[Math.floor(Math.random()*validMoves.length)];

    makeMove({row:choice.r,col:choice.c}, move);
    render();
}

function copyLink(){ navigator.clipboard.writeText(window.location.href).then(()=>alert("Lien copiÃ© !")); }
</script>
</body>
</html>