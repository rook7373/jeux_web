<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <title>Ã‰checs - Live</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background: radial-gradient(circle at center, #0f172a 0%, #000000 100%); color: white; min-height: 100vh; overflow-x: hidden; }
        .glass { background: rgba(255, 255, 255, 0.03); backdrop-filter: blur(12px); border: 1px solid rgba(255,255,255,0.1); }
        
        #board { 
            display: grid; 
            grid-template-columns: repeat(8, 1fr); 
            grid-template-rows: repeat(8, 1fr);
            width: 100%; 
            max-width: 600px;
            aspect-ratio: 1 / 1;
            box-shadow: 0 25px 50px rgba(0,0,0,0.6); 
            border-radius: 0.5rem;
            overflow: hidden;
        }
        .square {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.8rem;
            cursor: pointer;
            position: relative;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .light { background-color: #e8d5c4; }
        .dark { background-color: #8b6f47; }
        .light .piece { color: #1a1a1a; text-shadow: 0 2px 6px rgba(0,0,0,0.5), 0 0 2px rgba(255,255,255,0.8); }
        .dark .piece { color: #ffffff; text-shadow: 0 2px 6px rgba(0,0,0,0.5), 0 0 2px rgba(0,0,0,0.8); }
        .selected { background-color: #a0c4ff !important; }
        .highlight-move { background-color: rgba(144, 238, 144, 0.6) !important; }
        .highlight-capture { background-color: rgba(255, 99, 71, 0.6) !important; }
        .piece { user-select: none; }
        .color-dot { width: 45px; height: 45px; border-radius: 50%; cursor: pointer; border: 4px solid #f1f5f9; transition: 0.3s; }
        .color-dot.active { border-color: #000000; transform: scale(1.3); box-shadow: 0 0 20px rgba(255,255,255,0.4); }
        input::placeholder { color: rgba(255,255,255,0.2); }
    </style>
</head>
<body class="p-4 flex items-center justify-center font-sans uppercase font-black">

    <div id="setup" class="max-w-md w-full bg-white p-10 rounded-[3.5rem] shadow-2xl text-slate-900 z-50">
        <h2 id="setup-title" class="text-4xl font-black mb-8 text-blue-600 text-center italic tracking-tighter uppercase">Ã‰CHECS ARENA</h2>
        
        <div id="mode-selector" class="grid grid-cols-2 gap-4 mb-8">
            <button type="button" onclick="setMode('local')" id="m-local" class="bg-blue-600 text-white py-4 rounded-2xl shadow-lg transition font-black">LOCAL</button>
            <button type="button" onclick="setMode('remote')" id="m-remote" class="bg-slate-200 text-slate-500 py-4 rounded-2xl transition font-black">EN LIGNE</button>
        </div>

        <div id="local-options" class="space-y-4 mb-8">
            <p class="text-center text-[10px] font-black text-slate-400">CHOIX DE L'ADVERSAIRE :</p>
            <div class="grid grid-cols-2 gap-3">
                <button type="button" onclick="setOpponent('ai')" id="opp-ai" class="bg-blue-600 text-white py-4 rounded-2xl text-xs font-black shadow-md">ðŸ¤– IA</button>
                <button type="button" onclick="setOpponent('human')" id="opp-human" class="bg-slate-200 text-slate-500 py-4 rounded-2xl text-xs font-black">ðŸ‘¤ HUMAIN</button>
            </div>
        </div>

        <div class="space-y-6">
            <div class="text-center">
                <p class="text-[10px] text-slate-400 mb-4 tracking-widest uppercase">COULEUR DES PIONS</p>
                <div class="flex justify-center gap-4 flex-wrap">
                    <div onclick="setColor('white')" id="c-white" class="color-dot bg-white active"></div>
                    <div onclick="setColor('black')" id="c-black" class="color-dot bg-black"></div>
                </div>
            </div>

            <input type="text" id="my-name-in" onkeydown="if(event.key === 'Enter') startAction()" placeholder="TON PSEUDO..." class="w-full bg-slate-100 border-2 border-slate-100 p-5 rounded-3xl outline-none text-xl text-center focus:border-blue-400 font-black uppercase">
            
            <button onclick="startAction()" class="w-full bg-black text-white py-6 rounded-[2rem] text-xl shadow-2xl active:scale-95 transition-all font-black">DÃ‰MARRER</button>
            <button onclick="window.location.href='index.html'" class="w-full text-slate-400 text-[10px] tracking-widest uppercase font-black py-2">RETOUR HUB</button>
        </div>
    </div>

    <div id="game" class="hidden max-w-4xl w-full glass p-8 rounded-[4rem] border border-white/10 shadow-2xl">
        <div class="flex justify-between items-center mb-8">
            <button onclick="window.location.href='index.html'" class="text-[10px] bg-white/10 px-6 py-3 rounded-full hover:bg-white/20 transition font-black">MENU</button>
            <div id="players-display" class="flex gap-8 text-[12px] tracking-widest items-center font-black"></div>
            <button onclick="copyLink()" id="btn-copy" class="hidden bg-blue-600 px-6 py-3 rounded-full text-[10px] font-black shadow-lg uppercase">LIEN</button>
        </div>
        <div class="flex justify-center mb-10">
            <div id="board"></div>
        </div>
        <div id="win-overlay" class="hidden text-center">
            <p id="win-text" class="text-5xl text-yellow-500 mb-8 italic tracking-tighter"></p>
            <button onclick="saveAndReset()" class="bg-white text-black px-12 py-5 rounded-full text-sm font-black shadow-xl hover:scale-105 transition uppercase">ENREGISTRER & QUITTER</button>
        </div>
    </div>

    <script>
        const API = 'api_chess.php';
        const ROWS = 8, COLS = 8;
        let roomId = new URLSearchParams(window.location.search).get('room');
        let myName = '', myColor = 'white', gameMode = roomId ? 'remote' : 'local', localOpponent = 'ai';
        let gameState = { 
            players: [], 
            board: [],
            currentPlayer: '', 
            lastMove: null, 
            gameOver: false, 
            winner: '',
            selectedPiece: null,
            possibleMoves: []
        };

        const initialBoard = [
            ['bR', 'bN', 'bB', 'bQ', 'bK', 'bB', 'bN', 'bR'],
            ['bP', 'bP', 'bP', 'bP', 'bP', 'bP', 'bP', 'bP'],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['wP', 'wP', 'wP', 'wP', 'wP', 'wP', 'wP', 'wP'],
            ['wR', 'wN', 'wB', 'wQ', 'wK', 'wB', 'wN', 'wR']
        ];

        function getPieceChar(piece) {
            const pieces = {
                'wP': 'â™™', 'wR': 'â™–', 'wN': 'â™˜', 'wB': 'â™—', 'wQ': 'â™•', 'wK': 'â™”',
                'bP': 'â™Ÿ', 'bR': 'â™œ', 'bN': 'â™ž', 'bB': 'â™', 'bQ': 'â™›', 'bK': 'â™š'
            };
            return pieces[piece] || '';
        }

        const isOnBoard = (r, c) => r >= 0 && r < ROWS && c >= 0 && c < COLS;

        window.onload = () => {
            if(roomId) {
                document.getElementById('mode-selector').classList.add('hidden');
                document.getElementById('local-options').classList.add('hidden');
                document.getElementById('setup-title').innerHTML = "REJOINDRE <span class='text-slate-200'>ARENA</span>";
                gameMode = 'remote';
            } else {
                setMode('local');
                setOpponent('ai');
                setColor('white');
            }
        };

        function setMode(m) { 
            gameMode = m; 
            document.getElementById('m-local').className = (m === 'local') ? "bg-blue-600 text-white py-4 rounded-2xl shadow-lg font-black" : "bg-slate-200 text-slate-500 py-4 rounded-2xl font-black";
            document.getElementById('m-remote').className = (m === 'remote') ? "bg-blue-600 text-white py-4 rounded-2xl shadow-lg font-black" : "bg-slate-200 text-slate-500 py-4 rounded-2xl font-black";
            document.getElementById('local-options').classList.toggle('hidden', m !== 'local');
        }

        function setOpponent(opp) { 
            localOpponent = opp; 
            document.getElementById('opp-ai').className = (opp === 'ai') ? "bg-blue-600 text-white py-4 rounded-2xl text-xs font-black shadow-md" : "bg-slate-200 text-slate-500 py-4 rounded-2xl text-xs font-black";
            document.getElementById('opp-human').className = (opp === 'human') ? "bg-blue-600 text-white py-4 rounded-2xl text-xs font-black shadow-md" : "bg-slate-200 text-slate-500 py-4 rounded-2xl text-xs font-black";
        }

        function setColor(c) { 
            myColor = c; 
            document.querySelectorAll('.color-dot').forEach(d => d.classList.remove('active')); 
            document.getElementById('c-' + c).classList.add('active'); 
        }

        async function startAction() {
            const name = document.getElementById('my-name-in').value.trim();
            if(!name) return alert("Veuillez entrer un pseudo pour commencer !");
            myName = name.toUpperCase();
            
            gameState.board = JSON.parse(JSON.stringify(initialBoard));

            if (gameMode === 'remote') {
                if (!roomId) roomId = Math.random().toString(36).substring(2, 8);
                window.history.pushState({}, '', `?room=${roomId}`);
                await syncPull();
                if (gameState.players.length === 1 && gameState.players[0].color === myColor) {
                    myColor = (myColor === 'white' ? 'black' : 'white');
                }
                if (!gameState.players.find(p => p.name === myName)) {
                    if (gameState.players.length < 2) {
                        gameState.players.push({ name: myName, color: myColor });
                        if (gameState.players.length === 1) gameState.currentPlayer = 'white';
                    } else return alert("Plein !");
                } 
                setInterval(syncPull, 2000);
            } else {
                gameState.players = [
                    { name: myName, color: myColor }, 
                    { name: localOpponent === 'ai' ? 'IA ðŸ¤–' : 'JOUEUR 2', color: (myColor === 'white' ? 'black' : 'white') }
                ];
                gameState.currentPlayer = 'white';
            }
            document.getElementById('setup').classList.add('hidden');
            document.getElementById('game').classList.remove('hidden');
            if(gameMode === 'remote') { document.getElementById('btn-copy').classList.remove('hidden'); await syncPush(); }
            render();
        }

        async function syncPush() { if(roomId) await fetch(`${API}?action=sync&roomId=${roomId}`, { method: 'POST', body: JSON.stringify(gameState) }); }
        
        async function syncPull() {
            if(!roomId) return;
            try { 
                const r = await fetch(`${API}?action=sync&roomId=${roomId}&t=${Date.now()}`); 
                const data = await r.json(); 
                if (data) { gameState = data; render(); } 
            } catch(e) { console.error("Sync pull failed:", e); }
        }

        function handleSquareClick(row, col) {
            if (gameState.gameOver || (gameMode === 'remote' && gameState.currentPlayer !== myColor)) return;

            const piece = gameState.board[row][col];
            const isMyPiece = piece && piece.charAt(0) === gameState.currentPlayer.charAt(0);

            if (gameState.selectedPiece) {
                const move = gameState.possibleMoves.find(m => m.row === row && m.col === col);
                if (move) {
                    makeMove(gameState.selectedPiece, {row, col});
                    gameState.selectedPiece = null;
                    gameState.possibleMoves = [];
                    
                    if (!gameState.gameOver) {
                        gameState.currentPlayer = (gameState.currentPlayer === 'white' ? 'black' : 'white');
                        if(gameMode === 'local' && localOpponent === 'ai' && gameState.currentPlayer.charAt(0) !== myColor.charAt(0)) {
                            setTimeout(aiMove, 1000);
                        }
                    }
                    
                    if (gameMode === 'remote') syncPush();
                    render();
                    return;
                }
            }

            if (isMyPiece) {
                gameState.selectedPiece = {row, col};
                gameState.possibleMoves = getPossibleMoves(row, col);
                render();
            }
        }

        function getPossibleMoves(row, col) {
            const piece = gameState.board[row][col];
            if (!piece) return [];

            const moves = [];
            const color = piece.charAt(0);
            const type = piece.charAt(1);
            const opponentColor = (color === 'w') ? 'b' : 'w';

            const isOpponent = (r, c) => isOnBoard(r, c) && gameState.board[r][c] && gameState.board[r][c].charAt(0) === opponentColor;
            const isEmpty = (r, c) => isOnBoard(r, c) && !gameState.board[r][c];
            const canMoveTo = (r, c) => isOnBoard(r, c) && (!gameState.board[r][c] || gameState.board[r][c].charAt(0) === opponentColor);

            if (type === 'P') {
                const direction = (color === 'w') ? -1 : 1;
                const oneStep = row + direction;
                if (isEmpty(oneStep, col)) moves.push({row: oneStep, col});
                if ((color === 'w' && row === 6) || (color === 'b' && row === 1)) {
                    if (isEmpty(oneStep, col) && isEmpty(row + 2 * direction, col)) {
                        moves.push({row: row + 2 * direction, col});
                    }
                }
                if (isOpponent(oneStep, col - 1)) moves.push({row: oneStep, col: col - 1});
                if (isOpponent(oneStep, col + 1)) moves.push({row: oneStep, col: col + 1});
            } else if (type === 'R') {
                const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
                for (const [dr, dc] of dirs) {
                    for (let i = 1; i < ROWS; i++) {
                        const nr = row + dr * i, nc = col + dc * i;
                        if (!isOnBoard(nr, nc)) break;
                        if (isEmpty(nr, nc)) moves.push({row: nr, col: nc});
                        else if (isOpponent(nr, nc)) { moves.push({row: nr, col: nc}); break; }
                        else break;
                    }
                }
            } else if (type === 'N') {
                const jumps = [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,-2], [1,2], [2,-1], [2,1]];
                for (const [dr, dc] of jumps) {
                    if (canMoveTo(row + dr, col + dc)) moves.push({row: row + dr, col: col + dc});
                }
            } else if (type === 'B') {
                const dirs = [[1,1], [1,-1], [-1,1], [-1,-1]];
                for (const [dr, dc] of dirs) {
                    for (let i = 1; i < ROWS; i++) {
                        const nr = row + dr * i, nc = col + dc * i;
                        if (!isOnBoard(nr, nc)) break;
                        if (isEmpty(nr, nc)) moves.push({row: nr, col: nc});
                        else if (isOpponent(nr, nc)) { moves.push({row: nr, col: nc}); break; }
                        else break;
                    }
                }
            } else if (type === 'Q') {
                const dirs = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
                for (const [dr, dc] of dirs) {
                    for (let i = 1; i < ROWS; i++) {
                        const nr = row + dr * i, nc = col + dc * i;
                        if (!isOnBoard(nr, nc)) break;
                        if (isEmpty(nr, nc)) moves.push({row: nr, col: nc});
                        else if (isOpponent(nr, nc)) { moves.push({row: nr, col: nc}); break; }
                        else break;
                    }
                }
            } else if (type === 'K') {
                const dirs = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]];
                for (const [dr, dc] of dirs) {
                    if (canMoveTo(row + dr, col + dc)) moves.push({row: row + dr, col: col + dc});
                }
            }
            
            // Filtrer les mouvements qui mettent le roi en Ã©chec
            return moves.filter(move => {
                const simulatedBoard = JSON.parse(JSON.stringify(gameState.board));
                simulatedBoard[move.row][move.col] = piece;
                simulatedBoard[row][col] = '';
                return !isKingInCheck(simulatedBoard, color);
            });
        }

        function isKingInCheck(board, kingColor) {
            let kingPos = null;
            const opponentColor = (kingColor === 'w') ? 'b' : 'w';
            
            // Trouver la position du roi
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] === kingColor + 'K') {
                        kingPos = {row: r, col: c};
                        break;
                    }
                }
                if (kingPos) break;
            }
            
            if (!kingPos) return false;
            
            // VÃ©rifier si une piÃ¨ce ennemie attaque le roi
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = board[r][c];
                    if (piece && piece.charAt(0) === opponentColor) {
                        if (canAttack(board, r, c, kingPos.row, kingPos.col, piece.charAt(1))) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function canAttack(board, fromRow, fromCol, toRow, toCol, pieceType) {
            const color = board[fromRow][fromCol].charAt(0);
            const opponentColor = (color === 'w') ? 'b' : 'w';
            const isOpponent = (r, c) => isOnBoard(r, c) && board[r][c] && board[r][c].charAt(0) === opponentColor;
            const isEmpty = (r, c) => isOnBoard(r, c) && !board[r][c];

            if (pieceType === 'P') {
                const direction = (color === 'w') ? -1 : 1;
                return (fromRow + direction === toRow && Math.abs(fromCol - toCol) === 1);
            } else if (pieceType === 'N') {
                const dr = Math.abs(fromRow - toRow);
                const dc = Math.abs(fromCol - toCol);
                return (dr === 2 && dc === 1) || (dr === 1 && dc === 2);
            } else if (pieceType === 'K') {
                return Math.abs(fromRow - toRow) <= 1 && Math.abs(fromCol - toCol) <= 1;
            } else if (pieceType === 'R' || pieceType === 'Q') {
                if (fromRow === toRow) {
                    const step = fromCol < toCol ? 1 : -1;
                    for (let c = fromCol + step; c !== toCol; c += step) {
                        if (board[fromRow][c]) return false;
                    }
                    return true;
                }
                if (fromCol === toCol) {
                    const step = fromRow < toRow ? 1 : -1;
                    for (let r = fromRow + step; r !== toRow; r += step) {
                        if (board[r][fromCol]) return false;
                    }
                    return true;
                }
            }
            if (pieceType === 'B' || pieceType === 'Q') {
                if (Math.abs(fromRow - toRow) === Math.abs(fromCol - toCol)) {
                    const dr = fromRow < toRow ? 1 : -1;
                    const dc = fromCol < toCol ? 1 : -1;
                    for (let r = fromRow + dr, c = fromCol + dc; r !== toRow; r += dr, c += dc) {
                        if (board[r][c]) return false;
                    }
                    return true;
                }
            }
            return false;
        }

        function makeMove(from, to) {
            const piece = gameState.board[from.row][from.col];
            gameState.board[to.row][to.col] = piece;
            gameState.board[from.row][from.col] = '';
            
            // Promotion du pion SEULEMENT s'il arrive Ã  la derniÃ¨re ligne
            const color = piece.charAt(0);
            if (piece.charAt(1) === 'P' && ((color === 'w' && to.row === 0) || (color === 'b' && to.row === 7))) {
                gameState.board[to.row][to.col] = color + 'Q';
            }
            
            checkGameEnd();
        }

        function checkGameEnd() {
            const currentColor = gameState.currentPlayer.charAt(0);
            const opponentColor = (currentColor === 'w') ? 'b' : 'w';
            
            // VÃ©rifier si le joueur actuel a des mouvements lÃ©gaux
            let hasLegalMove = false;
            for (let r = 0; r < ROWS && !hasLegalMove; r++) {
                for (let c = 0; c < COLS && !hasLegalMove; c++) {
                    const piece = gameState.board[r][c];
                    if (piece && piece.charAt(0) === currentColor) {
                        if (getPossibleMoves(r, c).length > 0) {
                            hasLegalMove = true;
                        }
                    }
                }
            }
            
            if (!hasLegalMove) {
                gameState.gameOver = true;
                // VÃ©rifier si c'est un Ã©chec et mat ou un pat
                if (isKingInCheck(gameState.board, currentColor)) {
                    gameState.winner = (currentColor === 'w') ? 'NOIR' : 'BLANC';
                } else {
                    gameState.winner = 'PAT (NULLE)';
                }
            }
        }

        function aiMove() {
            const color = gameState.currentPlayer.charAt(0);
            const allMoves = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = gameState.board[r][c];
                    if (piece && piece.charAt(0) === color) {
                        const moves = getPossibleMoves(r, c);
                        moves.forEach(m => allMoves.push({from: {row: r, col: c}, to: m}));
                    }
                }
            }
            if (allMoves.length > 0) {
                const move = allMoves[Math.floor(Math.random() * allMoves.length)];
                makeMove(move.from, move.to);
                gameState.currentPlayer = (gameState.currentPlayer === 'white' ? 'black' : 'white');
                if (gameMode === 'remote') syncPush();
                render();
            }
        }

        function render() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const squareEl = document.createElement('div');
                    squareEl.classList.add('square');
                    squareEl.classList.add(((r + c) % 2 === 0) ? 'light' : 'dark');
                    squareEl.onclick = () => handleSquareClick(r, c);

                    const piece = gameState.board[r][c];
                    if (piece) {
                        const pieceEl = document.createElement('span');
                        pieceEl.classList.add('piece');
                        pieceEl.innerHTML = getPieceChar(piece);
                        squareEl.appendChild(pieceEl);
                    }

                    if (gameState.selectedPiece && gameState.selectedPiece.row === r && gameState.selectedPiece.col === c) {
                        squareEl.classList.add('selected');
                    }
                    if (gameState.possibleMoves.some(m => m.row === r && m.col === c)) {
                        const target = gameState.board[r][c];
                        if (target && target.charAt(0) !== gameState.currentPlayer.charAt(0)) {
                            squareEl.classList.add('highlight-capture');
                        } else {
                            squareEl.classList.add('highlight-move');
                        }
                    }
                    boardEl.appendChild(squareEl);
                }
            }

            const p1 = gameState.players[0] || { name: '...', color: 'white' };
            const p2 = gameState.players[1] || { name: '...', color: 'black' };
            const p1Style = p1.color === 'white' ? 'text-gray-200' : 'text-gray-800';
            const p2Style = p2.color === 'white' ? 'text-gray-200' : 'text-gray-800';

            document.getElementById('players-display').innerHTML = `
                <span class="${gameState.currentPlayer === p1.color ? 'ring-2 ring-white/20 bg-white/5' : 'opacity-40'} px-4 py-2 rounded-2xl ${p1Style}">${p1.name}</span>
                <span class="text-slate-700 font-bold italic">VS</span>
                <span class="${gameState.currentPlayer === p2.color ? 'ring-2 ring-white/20 bg-white/5' : 'opacity-40'} px-4 py-2 rounded-2xl ${p2Style}">${p2.name}</span>
            `;

            if (gameState.gameOver) { 
                document.getElementById('win-overlay').classList.remove('hidden'); 
                document.getElementById('win-text').innerText = gameState.winner + " GAGNE !"; 
            } else {
                document.getElementById('win-overlay').classList.add('hidden');
            }
        }

        async function saveAndReset() {
            const gameData = { 
                game: "Ã‰checs", 
                date: new Date().toLocaleDateString('fr-FR'), 
                results: gameState.players.map(p => ({ name: p.name, score: p.name === gameState.winner ? 1 : 0 })), 
                winner: gameState.winner 
            };
            try { 
                const r = await fetch(`${API}?action=stats`); 
                let history = await r.json(); 
                if (!Array.isArray(history)) history = []; 
                history.push(gameData);
                await fetch(`${API}?action=stats`, { method: 'POST', body: JSON.stringify(history) }); 
                window.location.href = 'index.html';
            } catch (e) { console.error("Save and reset failed:", e); window.location.href = 'index.html'; }
        }

        function copyLink() { navigator.clipboard.writeText(window.location.href); alert("LIEN COPIÃ‰ !"); }
    </script>
</body>
</html>
